# Leanna Garner === Student ID 010636491 === C950 Project
import datetime
import Package
import HashTable
import CSVRead
import Truck
import sys

"""
=== INITIALIZATION ===
This portion creates a hash table, adds packages to it,
and then creates truck objects so that the package IDs can be stored in them.

$$$ I could've simply passed in a list for the trucks' package lists, but
I thought that loading each package itself would be better. It updates the
package status too, because it's using the hash table's search function which
does return the package object itself, so it takes care of two things at once.
"""

pkg_table = HashTable.HashTable()
CSVRead.add_pkgs(pkg_table)
truck_1 = Truck.Truck(1, datetime.timedelta(hours=8, minutes=0, seconds=0))  # Leaves at 8AM
truck_2 = Truck.Truck(2, datetime.timedelta(hours=9, minutes=5, seconds=0))  # Leaves at 9:05AM
truck_3 = Truck.Truck(3, None)  # Will leave when one of the other trucks comes back
pkg_set_1 = [39, 13, 8, 30, 37, 1, 4, 40, 21, 20, 31, 19, 14, 16, 34, 15]
pkg_set_2 = [3, 5, 38, 36, 17, 6, 28, 2, 33, 12, 32, 25, 18, 11, 26, 23]
pkg_set_3 = [7, 29, 10, 27, 35, 24, 22, 9]
for pkg in pkg_set_1:
    truck_1.load_pkg(pkg_table.search(pkg))
for pkg in pkg_set_2:
    truck_2.load_pkg(pkg_table.search(pkg))
for pkg in pkg_set_3:
    truck_3.load_pkg(pkg_table.search(pkg))

"""
=== ALGORITHM ===
Since package loading was handled manually, the algorithm below is to find
the most appropriate route to deliver the packages, using the nearest-neighbor algorithm.

It compares the path generated by NN with no constraints and the one where packages with a
deadline are prioritized.

$$$ I think I could've created an algorithm to load, since I loaded them 
according to their constraints primarily (those with a deadline should have 
higher priority for delivery) and what packages could be delivered that were nearby 
or at the same address as those packages.
"""


def sorted_by_time(pkg_list: list):
    """
    Sorts a truck's list by the time. It will move all EOD deadline packages to the end of the list.
    :param pkg_list: list to sort
    :return: sorted list of packages
    """
    new_list = []
    for pkg in pkg_list:
        pkg_obj = pkg_table.search(pkg)
        new_list.append(pkg_obj)

    def time_sort(pkg: Package.Package):
        """
        A function to act as a key by sorting by time.

        **Time Complexity:** O(1)

        :param pkg: package
        :return: package's deadline
        """
        return pkg.deadline

    def eod_pick(pkg: Package.Package):
        """
        A function to act as a filter to find which are marked as "EOD".

        **Time Complexity:** O(1)

        :param pkg: package
        :return: boolean if package has EOD deadline
        """
        return pkg.deadline == "EOD"

    eod_list = list(filter(eod_pick, new_list))
    for pkg in eod_list:
        new_list.remove(pkg)
    new_list = list(sorted(new_list, key=time_sort, reverse=True) + eod_list)
    return new_list


def combined_odo():
    """
    Totals all three trucks' mileage for this program.
    :return: sum of all three trucks' mileage
    """
    return truck_1.odo + truck_2.odo + truck_3.odo


sorted_truck_1_list = sorted_by_time(truck_1.pkg_list)
sorted_truck_2_list = sorted_by_time(truck_2.pkg_list)
sorted_truck_3_list = sorted_by_time(truck_3.pkg_list)


# print(sorted_truck_3_list)  # It is a list of packages


def find_nearest_neighbor(current_addr: int, remaining_list: list[Package.Package], truck: Truck.Truck):
    """
    Finds the closest node to the current address.

    Uses the distance matrix to find the closest address.

    It does not account for the possibility that the closest package is at the same node,
    that will be taken cared of in create_route(). It doesn't look at the time constraints, either.

    :param current_addr: current address' ID number
    :param remaining_list: list of packages left (package objects)
    :param truck: truck object detail to change current address + count mileage
    :return: package that is closest and miles
    """
    closest_node: Package.Package = None
    closest_address_id: int = None  # Holds ID of the current closest address
    closest_address_distance: float = None  # Holds the actual shortest distance from current node
    print(f"\nüöõ Departing from {CSVRead.addr_name_lookup(current_addr)}!")
    for pkg in remaining_list:
        """print(f'Current address: {CSVRead.addr_name_lookup(current_addr)}\n'
              f'Inspecting address: {pkg.address}')"""
        dest_addr_id = pkg.addr_id_lookup()
        spec_addr_distance = CSVRead.dist_mtx_lookup(current_addr, dest_addr_id)
        """print(f'== From {CSVRead.addr_name_lookup(current_addr)} to '
              f'{pkg.address} is {spec_addr_distance} mi away.')"""
        if closest_address_id == None:
            # If the variable is None, initialize it to the first package it comes across.
            closest_address_id = dest_addr_id
            closest_node = pkg
            closest_address_distance = spec_addr_distance

        elif spec_addr_distance < closest_address_distance:
            # If the current iteration has closer address, replace the past ID with this one
            closest_address_id = dest_addr_id
            closest_node = pkg
            closest_address_distance = spec_addr_distance
    print(f"‚û°Ô∏è‚û°Ô∏è üó∫Ô∏è Will travel {closest_address_distance} miles")
    add_to_odo(closest_address_distance, truck)
    time_taken = truck.calc_time_taken(closest_address_distance)
    arrival_time = truck.update_cur_time(time_taken)
    print(f"‚û°Ô∏è‚û°Ô∏è ‚è∞ Arrives at {CSVRead.addr_name_lookup(closest_address_id)} at {arrival_time}")
    truck.denote_delivered(closest_node.id_num, pkg_table, arrival_time)
    return closest_node


def find_same_addr(pkg_list: list[int], addr):
    same_addr_list = []
    for pkg in pkg_list:
        package: Package.Package = pkg_table.search(pkg)
        this_pkg_addr = package.address
        if this_pkg_addr == addr:
            same_addr_list.append(package)
    return same_addr_list


def create_route(pkg_list: list[int], truck: Truck.Truck):
    """
    :param pkg_list: The original loading list for the truck that contains only IDs
    :param truck: The truck being used
    :return: a list of pkg id to visit in that order
    """
    output_route = []
    truck_pkg_obj_list = [pkg_table.search(package) for package in pkg_list]
    dummy_list = pkg_list.copy()  # To not mutate original list
    # print(f"dummy list {dummy_list}")
    current_addr = truck.fetch_curr_addr_id()  # Initially the WGU hub, uses the ID number
    while len(dummy_list) > 0:
        temp_list = []  # stores all id num to insert into the list
        chosen_package = find_nearest_neighbor(current_addr, truck_pkg_obj_list, truck)  # Has its delivery time
        print(f'üì¶ Chose the package: {chosen_package}')
        temp_list.append(chosen_package.id_num)  # appending the nearest package first
        dummy_list.remove(chosen_package.id_num)
        truck_pkg_obj_list.remove(chosen_package)
        same_addr_pkg_list = find_same_addr(dummy_list, chosen_package.address)
        for pkg in same_addr_pkg_list:
            print(f'‚û°Ô∏è‚û°Ô∏è üì¶ same address pkg: {pkg}')
            truck.denote_delivered(pkg.id_num, pkg_table, chosen_package.delivery_time)
            temp_list.append(pkg.id_num)  # appending same addresses afterwards
            dummy_list.remove(pkg.id_num)
            truck_pkg_obj_list.remove(pkg)
        current_addr = CSVRead.addr_id_lookup(chosen_package.address)  # reassign
        for pkg_id in temp_list:
            if pkg_table.search(pkg_id).deadline != "EOD":
                print(f"ü§î ID# {pkg_id} meets deadline? {check_deadline(pkg_id)}")
            else:
                print(f"ü§î ID# {pkg_id} meets deadline? {True}")
            output_route.append(pkg_id)
    return output_route


def add_to_odo(mileage: float, truck: Truck.Truck):
    truck.odo += mileage


def check_deadline(pkg_id: int):
    """
    Returns true if all packages are within deadline constraint;
    false if not.
    :param pkg_id_list:
    :return:
    """
    pkg = pkg_table.search(pkg_id)
    if not pkg.delivery_time <= pkg.deadline:
        return False  # breaks constraint
    return True  # passes constraint

print(f'‚ú® Truck 1 Travel! ~~~~~~~~~~~~~~~~~~~~~')
truck_1_route = create_route(pkg_set_1, truck_1)
print(f'\n‚ú® Truck 2 Travel! ~~~~~~~~~~~~~~~~~~~~~')
truck_2_route = create_route(pkg_set_2, truck_2)
#truck_3_route = create_route(pkg_set_3, truck_3)
print(f"\nüìù Truck 1 total miles traveled {truck_1.odo}")
print(f"üìù Truck 1 started route at {truck_1.departure_time}")
print(f"üìù Truck 1 finished route at {truck_1.current_time}")
print(f'üß≠ Route, in ID numbers {truck_1_route}')

print(f"\nüìù Truck 2 total miles traveled {truck_2.odo}")
print(f"üìù Truck 2 started route at {truck_2.departure_time}")
print(f"üìù Truck 2 finished route at {truck_2.current_time}")
print(f'üß≠ Route, in ID numbers {truck_2_route}')

print(f"Package 15 delivery time and status: {pkg_table.search(15).status} at {pkg_table.search(15).delivery_time}")
"""
for pkg_id in truck_1_route:
    pkg_obj: Package.Package = pkg_table.search(pkg_id)
    print(f'Pkg ID #{pkg_id} with deadline == {pkg_obj.deadline} == is {pkg_obj.status} at {pkg_obj.delivery_time}')
"""